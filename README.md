# architectural-patterns


This repository contains a Python implementation of various software architecture patterns. It serves as a practical demonstration, showcasing how these patterns can be applied to develop robust and scalable software systems.

Implemented Patterns:

1. Layered Architecture Pattern: The codebase follows the Layered Architecture pattern, dividing the application into presentation, business logic, and data access layers. Each layer has specific responsibilities and communicates with adjacent layers through well-defined interfaces.
2. Client-Server Pattern: The codebase demonstrates the Client-Server pattern, enabling communication and data exchange between clients and a central server.
3. Master-Slave Pattern: This pattern involves a master component delegating tasks to one or more slave components for parallel processing.
4. Pipe-Filter Pattern: The codebase incorporates the Pipe-Filter pattern, processing data sequentially through a series of filters connected by pipes. This allows for modular and reusable data transformations.
5. Broker Pattern: The codebase utilizes the Broker pattern, which involves a central broker acting as an intermediary for communication and coordination between components. It enables publishers to send messages to specific topics and delivers those messages to interested subscribers.
6. Peer-to-Peer Pattern: The codebase demonstrates the Peer-to-Peer pattern, a decentralized communication model where all participants (peers) have equal capabilities and can act as both clients and servers. Peers establish direct connections with each other to exchange data or perform distributed tasks without relying on a central server.
7. Event-bus Pattern: The codebase showcases the Event-bus pattern, facilitating decoupled communication between components through a central event bus. Components can publish events to the event bus, and other components can subscribe to specific event types and handle them accordingly.
8. Model-View-Controller (MVC) Pattern: The codebase exemplifies the Model-View-Controller pattern, a widely used architectural pattern for developing user interfaces. It separates the application into three interconnected components: the Model, the View, and the Controller. This pattern promotes separation of concerns, enhancing code maintainability and reusability.
9. Blackboard Pattern: The codebase demonstrates the Blackboard pattern, an architectural pattern that enables collaboration among multiple specialized modules or agents to solve complex problems. It utilizes a shared knowledge repository called the "blackboard," where modules can read from and write to. Modules, known as "knowledge sources," independently contribute their expertise to the blackboard, collectively working towards a solution. The blackboard acts as a central hub for communication and coordination, facilitating information exchange and knowledge updates. The Blackboard pattern is particularly useful in domains involving complex problem-solving, such as artificial intelligence, data analysis, and optimization.
10. Interpreter Pattern: The codebase showcases the Interpreter pattern, a design pattern that defines a grammar for a language and provides an interpreter to evaluate and execute expressions in that language. It involves several key components, including Abstract Expression, Terminal Expressions, Non-Terminal Expressions, and Context. The codebase implements an arithmetic expression interpreter, allowing users to enter arithmetic expressions that the interpreter evaluates and displays the result. This pattern is useful when interpreting and evaluating textual expressions or languages is required.